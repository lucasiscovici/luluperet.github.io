Servlet Xxx -> extends HttpServlet</br>
			-> @override DoGet</br>
				-> Appelle son Service associé (les Services commencent par un S suivi du nom de Servlet)</br>
				-> new SXxx(HttpServletRequest req, HttpServletResponse resp)</br>
				-> Cette appelle va appeler le Service associé et l'éxécuter, la reponse de cette appel sera dans la variable Resp du Service</br>
				-> pour l'afficher on peux directement invoquer la methode print() au Service (new SXxx(HttpServletRequest req, HttpServletResponse resp).print())</br>
</br>
service SXxx -> extends Service</br>
			 -> @override giveGetEntry -> données d'entrées obligatoire pour le service (array of strings) (données sont dans params)</br>
			 -> @override to_json -> données de sorties obligatoires pour le service (array of strings) (données sont dans Local_params)</br>
			 -> @override koko -> methode general du service qui est appellé a sa construction</br>
			 				->!!!! METTRE APRES UN RESP.C(t,e) UN RETURN; !!!!!</br>
			 -> Convention -> Pour les Checks courant -> utiliser la class TestError (Check params, auth)</br>
			 			   -> SORTIE EN JSON -></br>
			 			   					 -> SI ERREUR = {"code":"X",...}</br>
			 			   					 -> SI SUCCESS = {"response":...}</br>
			 			   					 -> SI RETOUR AVEC UNE SEUL LIGNE = {"response":{...}}</br>
			 			   					 -> SI RETOUR AVEC PLUSIEURS LIGNES = {"response":[{},{},...]}</br>
			 			   					 -> SI INSERTS -> {"response":{"id":"X"}}</br>
			 			   					 -> SI DELETE(REMOVE)/UPDATE -> {"response":"OK"}</br>
			 			   					 		-> CAS POUR TOUT SUPPRIMER (TYPE=ALL)</br>
			 			   					 -> SI SELECT (GENERALEMENT AVEC UN SOUS DICTIONNAIRE JSON Y)</br>
			 			   					 			 -> SI UNE LIGNE = {"response":{"Y":{...}}}</br>
			 			   					 			 -> SI PLUSIEURS LIGNES = {"response":{"Y":[{},{},...]}}</br>
			 			   					 -> !!!! IMPORTANT -> METTRE DANS Local_params les données dont on a besoin pour la sortie JSON !!!! ensuite on fait un RespS.cj(this);</br>
			 			   -> NE PAS FAIRE DE TRAITEMENTS SUR LES PARAMS ENVOYÉS AU HELPERS (db_*_Helper)(on ne met que comme argument de la fct appellée: params (type Parameters) (CE SONT LES FCTS DES HELPERS QUI FERONT UN TRAITEMENT)</br>
							</br>
-> POUR CHAQUE PAQUAGE -> SAddX + SListX + SRemoveX</br>
 SI SERVICE = SListX  -> </br>
						-> CAS AVEC ID DE LA ROW ( ENTRY GET  = ID)</br>
			   			-> CAS POUR TOUT SELECTIONNER (ENTRY GET TYPE=ALL)</br>
			 = SRemoveX -> </br>
						-> CAS AVEC ID DE LA ROW ( ENTRY GET  = ID)</br>
						-> CAS POUR TOUT SELECTIONNER (ENTRY GET TYPE=ALL)</br>
									</br>
Service -> implements IOLUCAS, IParameters, TOJSON, ServiceKoko</br>
		-> variable params -> Contient toutes les données d'entrées au commencement + d'autre si besoin pendant koko</br>
		-> variable response DE IOLUCAS -> Pour les affichages or console</br>
		-> variable getEntry -> arrays of strings des données obligatoire au commencement</br>
		-> variable Local_params -> Contient toutes les données dont to_json a besoin pour créer la Response JSON</br>
		-> variable RespS -> Réponse du Service -> error(ERREUR) ou response(SUCCESS) (voir SORTIE EN JSON)</br>
		-> CONSTRUCTEURS() -> Tous les constructeurs vont directement ou indirectement affecter params, response et getEntry en fonctions de leurs parametres </br>
						 -> Appeler koko()</br>
		-> print() -> fonctions permettant au service d'afficher sa RespS</br>
		</br>
Parameters -> la structure de donnée qui est utilisé en sortie et en entrée de fonctions </br>
		   -> Elle utilise une liste de Dico</br>
		   -> Elle contient des fonctions qui facilise le traitement de données Parameters ou Dico</br>
		   -> FCTS TRES UTILISÉES -> AddParam, getValue, getDico, AddParamResponse, CheckIfErrParams, PS, response, AddParamRespOK, responseID</br>
</br>
Dico -> C'est une dictionaire (key:valeur) -> la valeur peut etre un string ou une liste de Dico ou rien</br>
										   -> Il ne peux le pas y avoir de key ou une false key ( si on veux ne mettre qu'une valeur sans clé)</br>
	 -> Contient des facilitants le traitement de données</br>
	 -> FCTS TRES UTILISÉES -> vs_ak, response, toJSON, getValue, getKey, getValues,to_P, vT_toP</br>
</br>
RespS -> Class pour la reponse du Service</br>
Error -> Class pour les erreurs (code, description, detail)</br>
TestError -> Class pour les Checks recurrent -> appelles des bonnes methodes des helpers + creation de la bonne resp avec la bonne erreur</br>
</br>
db_*_Helper -> extend db ou dbM (MySQL, MongoDB)</br>
			-> @override Insert</br>
			-> @override Remove</br>
			-> @override Update</br>
			-> @override Select</br>
			-> @override GiveMyTable -> On renseigne sa TABLE !!!</br>
			-> Conventions </br>
						  -> On ecrit dans des variables toutes les strings dont on a besoin dans son helper ou cas ou elles changeraient en DB</br>
						  -> On fait appelle a des fcts de sa superclass (db ou dbM) en priorité , mais sinon celle de db_Helper</br>
						  -> POUR LES INSERTS -> On rajoute si Success, dont le params envoyé en parametre l'id de la Row inseré en DB ("id":X)</br>
						  -> Si on doit faire un traitement particulier sur des params et qu'on veux  faire appelle a une methode de la superclass -> ON l'OVERRIDE</br>
						  -> AVANT DE CHANGER DES CHOSES DANS UN params reçu en , on fait un copy(), ou on appelle un a fct qui fait une copy ou qui cree un nouveau Parameters directement ou indirectement</br>
</br>
db -> Contient des fct recurente pour SQL (insert, remove, update, select, etcccc )	</br>
dbM -> Contient des fct recurente pour MongoDB (insert, remove, update, select, etcccc )	</br>
	-> id = _id = ObjectID</br>
</br>
db_helper -> contient toutes les fonctions neccésaire pour excécuter du SQL ou du MongoDB </br>
		  -> Contient de fonctions qui créer les requetes </br>
		  -> toutes les entrées pour c'est fonctions si besoin sont des params (Parameters)</br>
		  -> toutes les sorties si besoin sont des params (Parameters)</br>
		  -> DELETE(REMOVE) SI COUNT OF REMOVE ROW == 0 RENVOI OK QD MM</br>